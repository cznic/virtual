// Copyright 2017 The Virtual Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// Code generated by running "go generate". DO NOT EDIT.

// +build windows

package virtual

import (
	"fmt"
	"os"
	"syscall"
)

var (
	modkernel32                   = syscall.NewLazyDLL("kernel32.dll")
	procAreFileApisANSI           = modkernel32.NewProc("AreFileApisANSI")
	procCreateFileA               = modkernel32.NewProc("CreateFileA")
	procCreateFileW               = modkernel32.NewProc("CreateFileW")
	procCreateFileMappingA        = modkernel32.NewProc("CreateFileMappingA")
	procCreateFileMappingW        = modkernel32.NewProc("CreateFileMappingW")
	procCreateMutexW              = modkernel32.NewProc("CreateMutexW")
	procCloseHandle               = modkernel32.NewProc("CloseHandle")
	procDeleteCriticalSection     = modkernel32.NewProc("DeleteCriticalSection")
	procDeleteFileA               = modkernel32.NewProc("DeleteFileA")
	procDeleteFileW               = modkernel32.NewProc("DeleteFileW")
	procEnterCriticalSection      = modkernel32.NewProc("EnterCriticalSection")
	procFlushFileBuffers          = modkernel32.NewProc("FlushFileBuffers")
	procFlushViewOfFile           = modkernel32.NewProc("FlushViewOfFile")
	procFormatMessageA            = modkernel32.NewProc("FormatMessageA")
	procFormatMessageW            = modkernel32.NewProc("FormatMessageW")
	procFreeLibrary               = modkernel32.NewProc("FreeLibrary")
	procGetCurrentProcessId       = modkernel32.NewProc("GetCurrentProcessId")
	procGetDiskFreeSpaceA         = modkernel32.NewProc("GetDiskFreeSpaceA")
	procGetDiskFreeSpaceW         = modkernel32.NewProc("GetDiskFreeSpaceW")
	procGetFileAttributesExW      = modkernel32.NewProc("GetFileAttributesExW")
	procGetFileAttributesA        = modkernel32.NewProc("GetFileAttributesA")
	procGetFileAttributesW        = modkernel32.NewProc("GetFileAttributesW")
	procGetFileSize               = modkernel32.NewProc("GetFileSize")
	procGetFullPathNameA          = modkernel32.NewProc("GetFullPathNameA")
	procGetFullPathNameW          = modkernel32.NewProc("GetFullPathNameW")
	procGetProcAddress            = modkernel32.NewProc("GetProcAddress")
	procGetProcessHeap            = modkernel32.NewProc("GetProcessHeap")
	procGetSystemInfo             = modkernel32.NewProc("GetSystemInfo")
	procGetSystemTime             = modkernel32.NewProc("GetSystemTime")
	procGetSystemTimeAsFileTime   = modkernel32.NewProc("GetSystemTimeAsFileTime")
	procGetTempPathA              = modkernel32.NewProc("GetTempPathA")
	procGetTempPathW              = modkernel32.NewProc("GetTempPathW")
	procGetTickCount              = modkernel32.NewProc("GetTickCount")
	procGetVersionExA             = modkernel32.NewProc("GetVersionExA")
	procGetVersionExW             = modkernel32.NewProc("GetVersionExW")
	procHeapAlloc                 = modkernel32.NewProc("HeapAlloc")
	procHeapCompact               = modkernel32.NewProc("HeapCompact")
	procHeapCreate                = modkernel32.NewProc("HeapCreate")
	procHeapDestroy               = modkernel32.NewProc("HeapDestroy")
	procHeapFree                  = modkernel32.NewProc("HeapFree")
	procHeapReAlloc               = modkernel32.NewProc("HeapReAlloc")
	procHeapSize                  = modkernel32.NewProc("HeapSize")
	procHeapValidate              = modkernel32.NewProc("HeapValidate")
	procInitializeCriticalSection = modkernel32.NewProc("InitializeCriticalSection")
	procLeaveCriticalSection      = modkernel32.NewProc("LeaveCriticalSection")
	procLoadLibraryA              = modkernel32.NewProc("LoadLibraryA")
	procLoadLibraryW              = modkernel32.NewProc("LoadLibraryW")
	procLocalFree                 = modkernel32.NewProc("LocalFree")
	procLockFile                  = modkernel32.NewProc("LockFile")
	procLockFileEx                = modkernel32.NewProc("LockFileEx")
	procMapViewOfFile             = modkernel32.NewProc("MapViewOfFile")
	procMultiByteToWideChar       = modkernel32.NewProc("MultiByteToWideChar")
	procOutputDebugStringA        = modkernel32.NewProc("OutputDebugStringA")
	procOutputDebugStringW        = modkernel32.NewProc("OutputDebugStringW")
	procQueryPerformanceCounter   = modkernel32.NewProc("QueryPerformanceCounter")
	procReadFile                  = modkernel32.NewProc("ReadFile")
	procSetEndOfFile              = modkernel32.NewProc("SetEndOfFile")
	procSetFilePointer            = modkernel32.NewProc("SetFilePointer")
	procSleep                     = modkernel32.NewProc("Sleep")
	procSystemTimeToFileTime      = modkernel32.NewProc("SystemTimeToFileTime")
	procUnlockFile                = modkernel32.NewProc("UnlockFile")
	procUnlockFileEx              = modkernel32.NewProc("UnlockFileEx")
	procUnmapViewOfFile           = modkernel32.NewProc("UnmapViewOfFile")
	procWaitForSingleObject       = modkernel32.NewProc("WaitForSingleObject")
	procWaitForSingleObjectEx     = modkernel32.NewProc("WaitForSingleObjectEx")
	procWideCharToMultiByte       = modkernel32.NewProc("WideCharToMultiByte")
	procWriteFile                 = modkernel32.NewProc("WriteFile")
)

func init() {
	registerBuiltins(map[int]Opcode{
		dict.SID("AreFileApisANSI"):           AreFileApisANSI,
		dict.SID("CreateFileA"):               CreateFileA,
		dict.SID("CreateFileW"):               CreateFileW,
		dict.SID("CreateFileMappingA"):        CreateFileMappingA,
		dict.SID("CreateFileMappingW"):        CreateFileMappingW,
		dict.SID("CreateMutexW"):              CreateMutexW,
		dict.SID("CloseHandle"):               CloseHandle,
		dict.SID("DeleteCriticalSection"):     DeleteCriticalSection,
		dict.SID("DeleteFileA"):               DeleteFileA,
		dict.SID("DeleteFileW"):               DeleteFileW,
		dict.SID("EnterCriticalSection"):      EnterCriticalSection,
		dict.SID("FlushFileBuffers"):          FlushFileBuffers,
		dict.SID("FlushViewOfFile"):           FlushViewOfFile,
		dict.SID("FormatMessageA"):            FormatMessageA,
		dict.SID("FormatMessageW"):            FormatMessageW,
		dict.SID("FreeLibrary"):               FreeLibrary,
		dict.SID("GetCurrentProcessId"):       GetCurrentProcessId,
		dict.SID("GetDiskFreeSpaceA"):         GetDiskFreeSpaceA,
		dict.SID("GetDiskFreeSpaceW"):         GetDiskFreeSpaceW,
		dict.SID("GetFileAttributesExW"):      GetFileAttributesExW,
		dict.SID("GetFileAttributesA"):        GetFileAttributesA,
		dict.SID("GetFileAttributesW"):        GetFileAttributesW,
		dict.SID("GetFileSize"):               GetFileSize,
		dict.SID("GetFullPathNameA"):          GetFullPathNameA,
		dict.SID("GetFullPathNameW"):          GetFullPathNameW,
		dict.SID("GetProcAddress"):            GetProcAddress,
		dict.SID("GetProcessHeap"):            GetProcessHeap,
		dict.SID("GetSystemInfo"):             GetSystemInfo,
		dict.SID("GetSystemTime"):             GetSystemTime,
		dict.SID("GetSystemTimeAsFileTime"):   GetSystemTimeAsFileTime,
		dict.SID("GetTempPathA"):              GetTempPathA,
		dict.SID("GetTempPathW"):              GetTempPathW,
		dict.SID("GetTickCount"):              GetTickCount,
		dict.SID("GetVersionExA"):             GetVersionExA,
		dict.SID("GetVersionExW"):             GetVersionExW,
		dict.SID("HeapAlloc"):                 HeapAlloc,
		dict.SID("HeapCompact"):               HeapCompact,
		dict.SID("HeapCreate"):                HeapCreate,
		dict.SID("HeapDestroy"):               HeapDestroy,
		dict.SID("HeapFree"):                  HeapFree,
		dict.SID("HeapReAlloc"):               HeapReAlloc,
		dict.SID("HeapSize"):                  HeapSize,
		dict.SID("HeapValidate"):              HeapValidate,
		dict.SID("InitializeCriticalSection"): InitializeCriticalSection,
		dict.SID("LeaveCriticalSection"):      LeaveCriticalSection,
		dict.SID("LoadLibraryA"):              LoadLibraryA,
		dict.SID("LoadLibraryW"):              LoadLibraryW,
		dict.SID("LocalFree"):                 LocalFree,
		dict.SID("LockFile"):                  LockFile,
		dict.SID("LockFileEx"):                LockFileEx,
		dict.SID("MapViewOfFile"):             MapViewOfFile,
		dict.SID("MultiByteToWideChar"):       MultiByteToWideChar,
		dict.SID("OutputDebugStringA"):        OutputDebugStringA,
		dict.SID("OutputDebugStringW"):        OutputDebugStringW,
		dict.SID("QueryPerformanceCounter"):   QueryPerformanceCounter,
		dict.SID("ReadFile"):                  ReadFile,
		dict.SID("SetEndOfFile"):              SetEndOfFile,
		dict.SID("SetFilePointer"):            SetFilePointer,
		dict.SID("Sleep"):                     Sleep,
		dict.SID("SystemTimeToFileTime"):      SystemTimeToFileTime,
		dict.SID("UnlockFile"):                UnlockFile,
		dict.SID("UnlockFileEx"):              UnlockFileEx,
		dict.SID("UnmapViewOfFile"):           UnmapViewOfFile,
		dict.SID("WaitForSingleObject"):       WaitForSingleObject,
		dict.SID("WaitForSingleObjectEx"):     WaitForSingleObjectEx,
		dict.SID("WideCharToMultiByte"):       WideCharToMultiByte,
		dict.SID("WriteFile"):                 WriteFile,
	})
}

// //sys: BOOL   	AreFileApisANSI();
func (c *cpu) AreFileApisANSI() {

	ret, _, err := syscall.Syscall(procAreFileApisANSI.Addr(), 0, 0,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "AreFileApisANSI() %#x %v\n", ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: HANDLE 	CreateFileA(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
func (c *cpu) CreateFileA() {
	sp := c.sp
	sp, hTemplateFile := popPtr(sp)
	sp, dwFlagsAndAttributes := popI32(sp)
	sp, dwCreationDisposition := popI32(sp)
	sp, lpSecurityAttributes := popPtr(sp)
	sp, dwShareMode := popI32(sp)
	sp, dwDesiredAccess := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall9(procCreateFileA.Addr(), 7, lpFileName,
		uintptr(dwDesiredAccess),
		uintptr(dwShareMode),
		lpSecurityAttributes,
		uintptr(dwCreationDisposition),
		uintptr(dwFlagsAndAttributes),
		hTemplateFile,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "CreateFileA(%s, %#x, %#x, %#x, %#x, %#x, %#x) %#x %v\n", GoUTF16String(lpFileName),
			dwDesiredAccess,
			dwShareMode,
			lpSecurityAttributes,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			hTemplateFile,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: HANDLE 	CreateFileW(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
func (c *cpu) CreateFileW() {
	sp := c.sp
	sp, hTemplateFile := popPtr(sp)
	sp, dwFlagsAndAttributes := popI32(sp)
	sp, dwCreationDisposition := popI32(sp)
	sp, lpSecurityAttributes := popPtr(sp)
	sp, dwShareMode := popI32(sp)
	sp, dwDesiredAccess := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall9(procCreateFileW.Addr(), 7, lpFileName,
		uintptr(dwDesiredAccess),
		uintptr(dwShareMode),
		lpSecurityAttributes,
		uintptr(dwCreationDisposition),
		uintptr(dwFlagsAndAttributes),
		hTemplateFile,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "CreateFileW(%s, %#x, %#x, %#x, %#x, %#x, %#x) %#x %v\n", GoUTF16String(lpFileName),
			dwDesiredAccess,
			dwShareMode,
			lpSecurityAttributes,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			hTemplateFile,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: HANDLE 	CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName);
func (c *cpu) CreateFileMappingA() {
	sp := c.sp
	sp, lpName := popPtr(sp)
	sp, dwMaximumSizeLow := popI32(sp)
	sp, dwMaximumSizeHigh := popI32(sp)
	sp, flProtect := popI32(sp)
	sp, lpAttributes := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procCreateFileMappingA.Addr(), 6, hFile,
		lpAttributes,
		uintptr(flProtect),
		uintptr(dwMaximumSizeHigh),
		uintptr(dwMaximumSizeLow),
		lpName)
	if strace {
		fmt.Fprintf(os.Stderr, "CreateFileMappingA(%#x, %#x, %#x, %#x, %#x, %s) %#x %v\n", hFile,
			lpAttributes,
			flProtect,
			dwMaximumSizeHigh,
			dwMaximumSizeLow,
			GoUTF16String(lpName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: HANDLE 	CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName);
func (c *cpu) CreateFileMappingW() {
	sp := c.sp
	sp, lpName := popPtr(sp)
	sp, dwMaximumSizeLow := popI32(sp)
	sp, dwMaximumSizeHigh := popI32(sp)
	sp, flProtect := popI32(sp)
	sp, lpAttributes := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procCreateFileMappingW.Addr(), 6, hFile,
		lpAttributes,
		uintptr(flProtect),
		uintptr(dwMaximumSizeHigh),
		uintptr(dwMaximumSizeLow),
		lpName)
	if strace {
		fmt.Fprintf(os.Stderr, "CreateFileMappingW(%#x, %#x, %#x, %#x, %#x, %s) %#x %v\n", hFile,
			lpAttributes,
			flProtect,
			dwMaximumSizeHigh,
			dwMaximumSizeLow,
			GoUTF16String(lpName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: HANDLE 	CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName);
func (c *cpu) CreateMutexW() {
	sp := c.sp
	sp, lpName := popPtr(sp)
	sp, bInitialOwner := popI32(sp)
	sp, lpMutexAttributes := popPtr(sp)

	ret, _, err := syscall.Syscall(procCreateMutexW.Addr(), 3, lpMutexAttributes,
		uintptr(bInitialOwner),
		lpName)
	if strace {
		fmt.Fprintf(os.Stderr, "CreateMutexW(%#x, %#x, %s) %#x %v\n", lpMutexAttributes,
			bInitialOwner,
			GoUTF16String(lpName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: BOOL   	CloseHandle(HANDLE hObject);
func (c *cpu) CloseHandle() {
	sp := c.sp
	sp, hObject := popPtr(sp)

	ret, _, err := syscall.Syscall(procCloseHandle.Addr(), 1, hObject,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "CloseHandle(%#x) %#x %v\n", hObject,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: void   	DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
func (c *cpu) DeleteCriticalSection() {
	sp := c.sp
	sp, lpCriticalSection := popPtr(sp)

	ret, _, err := syscall.Syscall(procDeleteCriticalSection.Addr(), 1, lpCriticalSection,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "DeleteCriticalSection(%#x) %d %v\n", lpCriticalSection,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: BOOL   	DeleteFileA(LPCTSTR lpFileName);
func (c *cpu) DeleteFileA() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procDeleteFileA.Addr(), 1, lpFileName,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "DeleteFileA(%s) %#x %v\n", GoUTF16String(lpFileName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	DeleteFileW(LPCTSTR lpFileName);
func (c *cpu) DeleteFileW() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procDeleteFileW.Addr(), 1, lpFileName,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "DeleteFileW(%s) %#x %v\n", GoUTF16String(lpFileName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: void   	EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
func (c *cpu) EnterCriticalSection() {
	sp := c.sp
	sp, lpCriticalSection := popPtr(sp)

	ret, _, err := syscall.Syscall(procEnterCriticalSection.Addr(), 1, lpCriticalSection,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "EnterCriticalSection(%#x) %d %v\n", lpCriticalSection,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: BOOL   	FlushFileBuffers(HANDLE hFile);
func (c *cpu) FlushFileBuffers() {
	sp := c.sp
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall(procFlushFileBuffers.Addr(), 1, hFile,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "FlushFileBuffers(%#x) %#x %v\n", hFile,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL     FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush);
func (c *cpu) FlushViewOfFile() {
	sp := c.sp
	sp, dwNumberOfBytesToFlush := popPtr(sp)
	sp, lpBaseAddress := popPtr(sp)

	ret, _, err := syscall.Syscall(procFlushViewOfFile.Addr(), 2, lpBaseAddress,
		dwNumberOfBytesToFlush,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "FlushViewOfFile(%#x, %#x) %#x %v\n", lpBaseAddress,
			dwNumberOfBytesToFlush,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list* Arguments);
func (c *cpu) FormatMessageA() {
	sp := c.sp
	sp, Arguments := popPtr(sp)
	sp, nSize := popI32(sp)
	sp, lpBuffer := popPtr(sp)
	sp, dwLanguageId := popI32(sp)
	sp, dwMessageId := popI32(sp)
	sp, lpSource := popPtr(sp)
	sp, dwFlags := popI32(sp)

	ret, _, err := syscall.Syscall9(procFormatMessageA.Addr(), 7, uintptr(dwFlags),
		lpSource,
		uintptr(dwMessageId),
		uintptr(dwLanguageId),
		lpBuffer,
		uintptr(nSize),
		Arguments,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "FormatMessageA(%#x, %#x, %#x, %#x, %s, %#x, %#x) %#x %v\n", dwFlags,
			lpSource,
			dwMessageId,
			dwLanguageId,
			GoUTF16String(lpBuffer),
			nSize,
			Arguments,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list* Arguments);
func (c *cpu) FormatMessageW() {
	sp := c.sp
	sp, Arguments := popPtr(sp)
	sp, nSize := popI32(sp)
	sp, lpBuffer := popPtr(sp)
	sp, dwLanguageId := popI32(sp)
	sp, dwMessageId := popI32(sp)
	sp, lpSource := popPtr(sp)
	sp, dwFlags := popI32(sp)

	ret, _, err := syscall.Syscall9(procFormatMessageW.Addr(), 7, uintptr(dwFlags),
		lpSource,
		uintptr(dwMessageId),
		uintptr(dwLanguageId),
		lpBuffer,
		uintptr(nSize),
		Arguments,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "FormatMessageW(%#x, %#x, %#x, %#x, %s, %#x, %#x) %#x %v\n", dwFlags,
			lpSource,
			dwMessageId,
			dwLanguageId,
			GoUTF16String(lpBuffer),
			nSize,
			Arguments,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	FreeLibrary(HMODULE hModule);
func (c *cpu) FreeLibrary() {
	sp := c.sp
	sp, hModule := popPtr(sp)

	ret, _, err := syscall.Syscall(procFreeLibrary.Addr(), 1, hModule,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "FreeLibrary(%#x) %#x %v\n", hModule,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	GetCurrentProcessId();
func (c *cpu) GetCurrentProcessId() {

	ret, _, err := syscall.Syscall(procGetCurrentProcessId.Addr(), 0, 0,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetCurrentProcessId() %#x %v\n", ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	GetDiskFreeSpaceA(LPCTSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
func (c *cpu) GetDiskFreeSpaceA() {
	sp := c.sp
	sp, lpTotalNumberOfClusters := popPtr(sp)
	sp, lpNumberOfFreeClusters := popPtr(sp)
	sp, lpBytesPerSector := popPtr(sp)
	sp, lpSectorsPerCluster := popPtr(sp)
	sp, lpRootPathName := popPtr(sp)

	ret, _, err := syscall.Syscall6(procGetDiskFreeSpaceA.Addr(), 5, lpRootPathName,
		lpSectorsPerCluster,
		lpBytesPerSector,
		lpNumberOfFreeClusters,
		lpTotalNumberOfClusters,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetDiskFreeSpaceA(%s, %#x, %#x, %#x, %#x) %#x %v\n", GoUTF16String(lpRootPathName),
			lpSectorsPerCluster,
			lpBytesPerSector,
			lpNumberOfFreeClusters,
			lpTotalNumberOfClusters,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	GetDiskFreeSpaceW(LPCTSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
func (c *cpu) GetDiskFreeSpaceW() {
	sp := c.sp
	sp, lpTotalNumberOfClusters := popPtr(sp)
	sp, lpNumberOfFreeClusters := popPtr(sp)
	sp, lpBytesPerSector := popPtr(sp)
	sp, lpSectorsPerCluster := popPtr(sp)
	sp, lpRootPathName := popPtr(sp)

	ret, _, err := syscall.Syscall6(procGetDiskFreeSpaceW.Addr(), 5, lpRootPathName,
		lpSectorsPerCluster,
		lpBytesPerSector,
		lpNumberOfFreeClusters,
		lpTotalNumberOfClusters,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetDiskFreeSpaceW(%s, %#x, %#x, %#x, %#x) %#x %v\n", GoUTF16String(lpRootPathName),
			lpSectorsPerCluster,
			lpBytesPerSector,
			lpNumberOfFreeClusters,
			lpTotalNumberOfClusters,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	GetFileAttributesExW(LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
func (c *cpu) GetFileAttributesExW() {
	sp := c.sp
	sp, lpFileInformation := popPtr(sp)
	sp, fInfoLevelId := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetFileAttributesExW.Addr(), 3, lpFileName,
		uintptr(fInfoLevelId),
		lpFileInformation)
	if strace {
		fmt.Fprintf(os.Stderr, "GetFileAttributesExW(%s, %#x, %#x) %#x %v\n", GoUTF16String(lpFileName),
			fInfoLevelId,
			lpFileInformation,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	GetFileAttributesA(LPCTSTR lpFileName);
func (c *cpu) GetFileAttributesA() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetFileAttributesA.Addr(), 1, lpFileName,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetFileAttributesA(%s) %#x %v\n", GoUTF16String(lpFileName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	GetFileAttributesW(LPCTSTR lpFileName);
func (c *cpu) GetFileAttributesW() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetFileAttributesW.Addr(), 1, lpFileName,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetFileAttributesW(%s) %#x %v\n", GoUTF16String(lpFileName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
func (c *cpu) GetFileSize() {
	sp := c.sp
	sp, lpFileSizeHigh := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetFileSize.Addr(), 2, hFile,
		lpFileSizeHigh,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetFileSize(%#x, %#x) %#x %v\n", hFile,
			lpFileSizeHigh,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	GetFullPathNameA( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart);
func (c *cpu) GetFullPathNameA() {
	sp := c.sp
	sp, lpFilePart := popPtr(sp)
	sp, lpBuffer := popPtr(sp)
	sp, nBufferLength := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall6(procGetFullPathNameA.Addr(), 4, lpFileName,
		uintptr(nBufferLength),
		lpBuffer,
		lpFilePart,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetFullPathNameA(%s, %#x, %s, %#x) %#x %v\n", GoUTF16String(lpFileName),
			nBufferLength,
			GoUTF16String(lpBuffer),
			lpFilePart,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	GetFullPathNameW( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart);
func (c *cpu) GetFullPathNameW() {
	sp := c.sp
	sp, lpFilePart := popPtr(sp)
	sp, lpBuffer := popPtr(sp)
	sp, nBufferLength := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall6(procGetFullPathNameW.Addr(), 4, lpFileName,
		uintptr(nBufferLength),
		lpBuffer,
		lpFilePart,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetFullPathNameW(%s, %#x, %s, %#x) %#x %v\n", GoUTF16String(lpFileName),
			nBufferLength,
			GoUTF16String(lpBuffer),
			lpFilePart,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: FARPROC 	GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
func (c *cpu) GetProcAddress() {
	sp := c.sp
	sp, lpProcName := popPtr(sp)
	sp, hModule := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetProcAddress.Addr(), 2, hModule,
		lpProcName,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetProcAddress(%#x, %s) %#x %v\n", hModule,
			GoUTF16String(lpProcName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: HANDLE   GetProcessHeap();
func (c *cpu) GetProcessHeap() {

	ret, _, err := syscall.Syscall(procGetProcessHeap.Addr(), 0, 0,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetProcessHeap() %#x %v\n", ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: void   	GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
func (c *cpu) GetSystemInfo() {
	sp := c.sp
	sp, lpSystemInfo := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetSystemInfo.Addr(), 1, lpSystemInfo,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetSystemInfo(%#x) %d %v\n", lpSystemInfo,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: void   	GetSystemTime(LPSYSTEMTIME lpSystemTime);
func (c *cpu) GetSystemTime() {
	sp := c.sp
	sp, lpSystemTime := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetSystemTime.Addr(), 1, lpSystemTime,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetSystemTime(%#x) %d %v\n", lpSystemTime,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: void     GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
func (c *cpu) GetSystemTimeAsFileTime() {
	sp := c.sp
	sp, lpSystemTimeAsFileTime := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetSystemTimeAsFileTime.Addr(), 1, lpSystemTimeAsFileTime,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetSystemTimeAsFileTime(%#x) %d %v\n", lpSystemTimeAsFileTime,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: DWORD    GetTempPathA(DWORD nBufferLength, LPTSTR lpBuffer);
func (c *cpu) GetTempPathA() {
	sp := c.sp
	sp, lpBuffer := popPtr(sp)
	sp, nBufferLength := popI32(sp)

	ret, _, err := syscall.Syscall(procGetTempPathA.Addr(), 2, uintptr(nBufferLength),
		lpBuffer,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetTempPathA(%#x, %s) %#x %v\n", nBufferLength,
			GoUTF16String(lpBuffer),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD    GetTempPathW(DWORD nBufferLength, LPTSTR lpBuffer);
func (c *cpu) GetTempPathW() {
	sp := c.sp
	sp, lpBuffer := popPtr(sp)
	sp, nBufferLength := popI32(sp)

	ret, _, err := syscall.Syscall(procGetTempPathW.Addr(), 2, uintptr(nBufferLength),
		lpBuffer,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetTempPathW(%#x, %s) %#x %v\n", nBufferLength,
			GoUTF16String(lpBuffer),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD  	GetTickCount();
func (c *cpu) GetTickCount() {

	ret, _, err := syscall.Syscall(procGetTickCount.Addr(), 0, 0,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetTickCount() %#x %v\n", ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	GetVersionExA(LPOSVERSIONINFO lpVersionInfo);
func (c *cpu) GetVersionExA() {
	sp := c.sp
	sp, lpVersionInfo := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetVersionExA.Addr(), 1, lpVersionInfo,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetVersionExA(%#x) %#x %v\n", lpVersionInfo,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	GetVersionExW(LPOSVERSIONINFO lpVersionInfo);
func (c *cpu) GetVersionExW() {
	sp := c.sp
	sp, lpVersionInfo := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetVersionExW.Addr(), 1, lpVersionInfo,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "GetVersionExW(%#x) %#x %v\n", lpVersionInfo,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: LPVOID 	HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
func (c *cpu) HeapAlloc() {
	sp := c.sp
	sp, dwBytes := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapAlloc.Addr(), 3, hHeap,
		uintptr(dwFlags),
		dwBytes)
	if strace {
		fmt.Fprintf(os.Stderr, "HeapAlloc(%#x, %#x, %#x) %#x %v\n", hHeap,
			dwFlags,
			dwBytes,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: SIZE_T   HeapCompact(HANDLE hHeap, DWORD dwFlags);
func (c *cpu) HeapCompact() {
	sp := c.sp
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapCompact.Addr(), 2, hHeap,
		uintptr(dwFlags),
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "HeapCompact(%#x, %#x) %#x %v\n", hHeap,
			dwFlags,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: HANDLE   HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
func (c *cpu) HeapCreate() {
	sp := c.sp
	sp, dwMaximumSize := popPtr(sp)
	sp, dwInitialSize := popPtr(sp)
	sp, flOptions := popI32(sp)

	ret, _, err := syscall.Syscall(procHeapCreate.Addr(), 3, uintptr(flOptions),
		dwInitialSize,
		dwMaximumSize)
	if strace {
		fmt.Fprintf(os.Stderr, "HeapCreate(%#x, %#x, %#x) %#x %v\n", flOptions,
			dwInitialSize,
			dwMaximumSize,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: BOOL     HeapDestroy(HANDLE hHeap);
func (c *cpu) HeapDestroy() {
	sp := c.sp
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapDestroy.Addr(), 1, hHeap,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "HeapDestroy(%#x) %#x %v\n", hHeap,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL     HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
func (c *cpu) HeapFree() {
	sp := c.sp
	sp, lpMem := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapFree.Addr(), 3, hHeap,
		uintptr(dwFlags),
		lpMem)
	if strace {
		fmt.Fprintf(os.Stderr, "HeapFree(%#x, %#x, %#x) %#x %v\n", hHeap,
			dwFlags,
			lpMem,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: LPVOID   HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
func (c *cpu) HeapReAlloc() {
	sp := c.sp
	sp, dwBytes := popPtr(sp)
	sp, lpMem := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall6(procHeapReAlloc.Addr(), 4, hHeap,
		uintptr(dwFlags),
		lpMem,
		dwBytes,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "HeapReAlloc(%#x, %#x, %#x, %#x) %#x %v\n", hHeap,
			dwFlags,
			lpMem,
			dwBytes,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: SIZE_T   HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
func (c *cpu) HeapSize() {
	sp := c.sp
	sp, lpMem := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapSize.Addr(), 3, hHeap,
		uintptr(dwFlags),
		lpMem)
	if strace {
		fmt.Fprintf(os.Stderr, "HeapSize(%#x, %#x, %#x) %#x %v\n", hHeap,
			dwFlags,
			lpMem,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: BOOL     HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
func (c *cpu) HeapValidate() {
	sp := c.sp
	sp, lpMem := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapValidate.Addr(), 3, hHeap,
		uintptr(dwFlags),
		lpMem)
	if strace {
		fmt.Fprintf(os.Stderr, "HeapValidate(%#x, %#x, %#x) %#x %v\n", hHeap,
			dwFlags,
			lpMem,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: void   	InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
func (c *cpu) InitializeCriticalSection() {
	sp := c.sp
	sp, lpCriticalSection := popPtr(sp)

	ret, _, err := syscall.Syscall(procInitializeCriticalSection.Addr(), 1, lpCriticalSection,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "InitializeCriticalSection(%#x) %d %v\n", lpCriticalSection,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: void   	LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
func (c *cpu) LeaveCriticalSection() {
	sp := c.sp
	sp, lpCriticalSection := popPtr(sp)

	ret, _, err := syscall.Syscall(procLeaveCriticalSection.Addr(), 1, lpCriticalSection,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "LeaveCriticalSection(%#x) %d %v\n", lpCriticalSection,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: HMODULE  LoadLibraryA(LPCTSTR lpFileName);
func (c *cpu) LoadLibraryA() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procLoadLibraryA.Addr(), 1, lpFileName,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "LoadLibraryA(%s) %#x %v\n", GoUTF16String(lpFileName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: HMODULE  LoadLibraryW(LPCTSTR lpFileName);
func (c *cpu) LoadLibraryW() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procLoadLibraryW.Addr(), 1, lpFileName,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "LoadLibraryW(%s) %#x %v\n", GoUTF16String(lpFileName),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: HLOCAL 	LocalFree(HLOCAL hMem);
func (c *cpu) LocalFree() {
	sp := c.sp
	sp, hMem := popPtr(sp)

	ret, _, err := syscall.Syscall(procLocalFree.Addr(), 1, hMem,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "LocalFree(%#x) %#x %v\n", hMem,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: BOOL     LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
func (c *cpu) LockFile() {
	sp := c.sp
	sp, nNumberOfBytesToLockHigh := popI32(sp)
	sp, nNumberOfBytesToLockLow := popI32(sp)
	sp, dwFileOffsetHigh := popI32(sp)
	sp, dwFileOffsetLow := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procLockFile.Addr(), 5, hFile,
		uintptr(dwFileOffsetLow),
		uintptr(dwFileOffsetHigh),
		uintptr(nNumberOfBytesToLockLow),
		uintptr(nNumberOfBytesToLockHigh),
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "LockFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile,
			dwFileOffsetLow,
			dwFileOffsetHigh,
			nNumberOfBytesToLockLow,
			nNumberOfBytesToLockHigh,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped);
func (c *cpu) LockFileEx() {
	sp := c.sp
	sp, lpOverlapped := popPtr(sp)
	sp, nNumberOfBytesToLockHigh := popI32(sp)
	sp, nNumberOfBytesToLockLow := popI32(sp)
	sp, dwReserved := popI32(sp)
	sp, dwFlags := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procLockFileEx.Addr(), 6, hFile,
		uintptr(dwFlags),
		uintptr(dwReserved),
		uintptr(nNumberOfBytesToLockLow),
		uintptr(nNumberOfBytesToLockHigh),
		lpOverlapped)
	if strace {
		fmt.Fprintf(os.Stderr, "LockFileEx(%#x, %#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile,
			dwFlags,
			dwReserved,
			nNumberOfBytesToLockLow,
			nNumberOfBytesToLockHigh,
			lpOverlapped,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: LPVOID   MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
func (c *cpu) MapViewOfFile() {
	sp := c.sp
	sp, dwNumberOfBytesToMap := popPtr(sp)
	sp, dwFileOffsetLow := popI32(sp)
	sp, dwFileOffsetHigh := popI32(sp)
	sp, dwDesiredAccess := popI32(sp)
	sp, hFileMappingObject := popPtr(sp)

	ret, _, err := syscall.Syscall6(procMapViewOfFile.Addr(), 5, hFileMappingObject,
		uintptr(dwDesiredAccess),
		uintptr(dwFileOffsetHigh),
		uintptr(dwFileOffsetLow),
		dwNumberOfBytesToMap,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "MapViewOfFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFileMappingObject,
			dwDesiredAccess,
			dwFileOffsetHigh,
			dwFileOffsetLow,
			dwNumberOfBytesToMap,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys: int 	  	MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr,	int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
func (c *cpu) MultiByteToWideChar() {
	sp := c.sp
	sp, cchWideChar := popI32(sp)
	sp, lpWideCharStr := popPtr(sp)
	sp, cbMultiByte := popI32(sp)
	sp, lpMultiByteStr := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, CodePage := popI32(sp)

	ret, _, err := syscall.Syscall6(procMultiByteToWideChar.Addr(), 6, uintptr(CodePage),
		uintptr(dwFlags),
		lpMultiByteStr,
		uintptr(cbMultiByte),
		lpWideCharStr,
		uintptr(cchWideChar))
	if strace {
		fmt.Fprintf(os.Stderr, "MultiByteToWideChar(%#x, %#x, %s, %#x, %s, %#x) %#x %v\n", CodePage,
			dwFlags,
			GoUTF16String(lpMultiByteStr),
			cbMultiByte,
			GoUTF16String(lpWideCharStr),
			cchWideChar,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: void     OutputDebugStringA(LPCTSTR lpOutputString);
func (c *cpu) OutputDebugStringA() {
	sp := c.sp
	sp, lpOutputString := popPtr(sp)

	ret, _, err := syscall.Syscall(procOutputDebugStringA.Addr(), 1, lpOutputString,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "OutputDebugStringA(%s) %d %v\n", GoUTF16String(lpOutputString),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: void     OutputDebugStringW(LPCTSTR lpOutputString);
func (c *cpu) OutputDebugStringW() {
	sp := c.sp
	sp, lpOutputString := popPtr(sp)

	ret, _, err := syscall.Syscall(procOutputDebugStringW.Addr(), 1, lpOutputString,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "OutputDebugStringW(%s) %d %v\n", GoUTF16String(lpOutputString),
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: BOOL   	QueryPerformanceCounter(LARGE_INTEGER* lpPerformanceCount);
func (c *cpu) QueryPerformanceCounter() {
	sp := c.sp
	sp, lpPerformanceCount := popPtr(sp)

	ret, _, err := syscall.Syscall(procQueryPerformanceCounter.Addr(), 1, lpPerformanceCount,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "QueryPerformanceCounter(%#x) %#x %v\n", lpPerformanceCount,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
func (c *cpu) ReadFile() {
	sp := c.sp
	sp, lpOverlapped := popPtr(sp)
	sp, lpNumberOfBytesRead := popPtr(sp)
	sp, nNumberOfBytesToRead := popI32(sp)
	sp, lpBuffer := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procReadFile.Addr(), 5, hFile,
		lpBuffer,
		uintptr(nNumberOfBytesToRead),
		lpNumberOfBytesRead,
		lpOverlapped,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "ReadFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile,
			lpBuffer,
			nNumberOfBytesToRead,
			lpNumberOfBytesRead,
			lpOverlapped,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL     SetEndOfFile(HANDLE hFile);
func (c *cpu) SetEndOfFile() {
	sp := c.sp
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall(procSetEndOfFile.Addr(), 1, hFile,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "SetEndOfFile(%#x) %#x %v\n", hFile,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD    SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
func (c *cpu) SetFilePointer() {
	sp := c.sp
	sp, dwMoveMethod := popI32(sp)
	sp, lpDistanceToMoveHigh := popPtr(sp)
	sp, lDistanceToMove := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procSetFilePointer.Addr(), 4, hFile,
		uintptr(lDistanceToMove),
		lpDistanceToMoveHigh,
		uintptr(dwMoveMethod),
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "SetFilePointer(%#x, %#x, %#x, %#x) %#x %v\n", hFile,
			lDistanceToMove,
			lpDistanceToMoveHigh,
			dwMoveMethod,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: void     Sleep(DWORD dwMilliseconds);
func (c *cpu) Sleep() {
	sp := c.sp
	sp, dwMilliseconds := popI32(sp)

	ret, _, err := syscall.Syscall(procSleep.Addr(), 1, uintptr(dwMilliseconds),
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "Sleep(%#x) %d %v\n", dwMilliseconds,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}

}

// //sys: BOOL     SystemTimeToFileTime(SYSTEMTIME* lpSystemTime, LPFILETIME lpFileTime);
func (c *cpu) SystemTimeToFileTime() {
	sp := c.sp
	sp, lpFileTime := popPtr(sp)
	sp, lpSystemTime := popPtr(sp)

	ret, _, err := syscall.Syscall(procSystemTimeToFileTime.Addr(), 2, lpSystemTime,
		lpFileTime,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "SystemTimeToFileTime(%#x, %#x) %#x %v\n", lpSystemTime,
			lpFileTime,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL     UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh);
func (c *cpu) UnlockFile() {
	sp := c.sp
	sp, nNumberOfBytesToUnlockHigh := popI32(sp)
	sp, nNumberOfBytesToUnlockLow := popI32(sp)
	sp, dwFileOffsetHigh := popI32(sp)
	sp, dwFileOffsetLow := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procUnlockFile.Addr(), 5, hFile,
		uintptr(dwFileOffsetLow),
		uintptr(dwFileOffsetHigh),
		uintptr(nNumberOfBytesToUnlockLow),
		uintptr(nNumberOfBytesToUnlockHigh),
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "UnlockFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile,
			dwFileOffsetLow,
			dwFileOffsetHigh,
			nNumberOfBytesToUnlockLow,
			nNumberOfBytesToUnlockHigh,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped);
func (c *cpu) UnlockFileEx() {
	sp := c.sp
	sp, lpOverlapped := popPtr(sp)
	sp, nNumberOfBytesToUnlockHigh := popI32(sp)
	sp, nNumberOfBytesToUnlockLow := popI32(sp)
	sp, dwReserved := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procUnlockFileEx.Addr(), 5, hFile,
		uintptr(dwReserved),
		uintptr(nNumberOfBytesToUnlockLow),
		uintptr(nNumberOfBytesToUnlockHigh),
		lpOverlapped,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "UnlockFileEx(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile,
			dwReserved,
			nNumberOfBytesToUnlockLow,
			nNumberOfBytesToUnlockHigh,
			lpOverlapped,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL     UnmapViewOfFile(LPCVOID lpBaseAddress);
func (c *cpu) UnmapViewOfFile() {
	sp := c.sp
	sp, lpBaseAddress := popPtr(sp)

	ret, _, err := syscall.Syscall(procUnmapViewOfFile.Addr(), 1, lpBaseAddress,
		0,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "UnmapViewOfFile(%#x) %#x %v\n", lpBaseAddress,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD    WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
func (c *cpu) WaitForSingleObject() {
	sp := c.sp
	sp, dwMilliseconds := popI32(sp)
	sp, hHandle := popPtr(sp)

	ret, _, err := syscall.Syscall(procWaitForSingleObject.Addr(), 2, hHandle,
		uintptr(dwMilliseconds),
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "WaitForSingleObject(%#x, %#x) %#x %v\n", hHandle,
			dwMilliseconds,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: DWORD    WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
func (c *cpu) WaitForSingleObjectEx() {
	sp := c.sp
	sp, bAlertable := popI32(sp)
	sp, dwMilliseconds := popI32(sp)
	sp, hHandle := popPtr(sp)

	ret, _, err := syscall.Syscall(procWaitForSingleObjectEx.Addr(), 3, hHandle,
		uintptr(dwMilliseconds),
		uintptr(bAlertable))
	if strace {
		fmt.Fprintf(os.Stderr, "WaitForSingleObjectEx(%#x, %#x, %#x) %#x %v\n", hHandle,
			dwMilliseconds,
			bAlertable,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: int    	WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
func (c *cpu) WideCharToMultiByte() {
	sp := c.sp
	sp, lpUsedDefaultChar := popPtr(sp)
	sp, lpDefaultChar := popPtr(sp)
	sp, cbMultiByte := popI32(sp)
	sp, lpMultiByteStr := popPtr(sp)
	sp, cchWideChar := popI32(sp)
	sp, lpWideCharStr := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, CodePage := popI32(sp)

	ret, _, err := syscall.Syscall9(procWideCharToMultiByte.Addr(), 8, uintptr(CodePage),
		uintptr(dwFlags),
		lpWideCharStr,
		uintptr(cchWideChar),
		lpMultiByteStr,
		uintptr(cbMultiByte),
		lpDefaultChar,
		lpUsedDefaultChar,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "WideCharToMultiByte(%#x, %#x, %s, %#x, %s, %#x, %s, %#x) %#x %v\n", CodePage,
			dwFlags,
			GoUTF16String(lpWideCharStr),
			cchWideChar,
			GoUTF16String(lpMultiByteStr),
			cbMultiByte,
			GoUTF16String(lpDefaultChar),
			lpUsedDefaultChar,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys: BOOL   	WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
func (c *cpu) WriteFile() {
	sp := c.sp
	sp, lpOverlapped := popPtr(sp)
	sp, lpNumberOfBytesWritten := popPtr(sp)
	sp, nNumberOfBytesToWrite := popI32(sp)
	sp, lpBuffer := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procWriteFile.Addr(), 5, hFile,
		lpBuffer,
		uintptr(nNumberOfBytesToWrite),
		lpNumberOfBytesWritten,
		lpOverlapped,
		0)
	if strace {
		fmt.Fprintf(os.Stderr, "WriteFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile,
			lpBuffer,
			nNumberOfBytesToWrite,
			lpNumberOfBytesWritten,
			lpOverlapped,
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}
