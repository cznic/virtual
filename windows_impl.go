// Copyright 2017 The Virtual Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// Code generated by running "go generate". DO NOT EDIT.

// +build windows

package virtual

import (
	"fmt"
	"syscall"
	"os"
)

var (
	modkernel32           = syscall.NewLazyDLL("kernel32.dll")
	procAreFileApisANSI                = modkernel32.NewProc("AreFileApisANSI")
	procCreateFileA                    = modkernel32.NewProc("CreateFileA")
	procCreateFileW                    = modkernel32.NewProc("CreateFileW")
	procCreateFileMappingA             = modkernel32.NewProc("CreateFileMappingA")
	procCreateFileMappingW             = modkernel32.NewProc("CreateFileMappingW")
	procCreateMutexW                   = modkernel32.NewProc("CreateMutexW")
	procCloseHandle                    = modkernel32.NewProc("CloseHandle")
	procDeleteCriticalSection          = modkernel32.NewProc("DeleteCriticalSection")
	procDeleteFileA                    = modkernel32.NewProc("DeleteFileA")
	procDeleteFileW                    = modkernel32.NewProc("DeleteFileW")
	procEnterCriticalSection           = modkernel32.NewProc("EnterCriticalSection")
	procFlushFileBuffers               = modkernel32.NewProc("FlushFileBuffers")
	procFlushViewOfFile                = modkernel32.NewProc("FlushViewOfFile")
	procFormatMessageA                 = modkernel32.NewProc("FormatMessageA")
	procFormatMessageW                 = modkernel32.NewProc("FormatMessageW")
	procFreeLibrary                    = modkernel32.NewProc("FreeLibrary")
	procGetCurrentProcessId            = modkernel32.NewProc("GetCurrentProcessId")
	procGetDiskFreeSpaceA              = modkernel32.NewProc("GetDiskFreeSpaceA")
	procGetDiskFreeSpaceW              = modkernel32.NewProc("GetDiskFreeSpaceW")
	procGetFileAttributesExW           = modkernel32.NewProc("GetFileAttributesExW")
	procGetFileAttributesA             = modkernel32.NewProc("GetFileAttributesA")
	procGetFileAttributesW             = modkernel32.NewProc("GetFileAttributesW")
	procGetFileSize                    = modkernel32.NewProc("GetFileSize")
	procGetFullPathNameA               = modkernel32.NewProc("GetFullPathNameA")
	procGetFullPathNameW               = modkernel32.NewProc("GetFullPathNameW")
	procGetProcAddress                 = modkernel32.NewProc("GetProcAddress")
	procGetProcessHeap                 = modkernel32.NewProc("GetProcessHeap")
	procGetSystemInfo                  = modkernel32.NewProc("GetSystemInfo")
	procGetSystemTime                  = modkernel32.NewProc("GetSystemTime")
	procGetSystemTimeAsFileTime        = modkernel32.NewProc("GetSystemTimeAsFileTime")
	procGetTempPathA                   = modkernel32.NewProc("GetTempPathA")
	procGetTempPathW                   = modkernel32.NewProc("GetTempPathW")
	procGetTickCount                   = modkernel32.NewProc("GetTickCount")
	procGetVersionExA                  = modkernel32.NewProc("GetVersionExA")
	procGetVersionExW                  = modkernel32.NewProc("GetVersionExW")
	procHeapAlloc                      = modkernel32.NewProc("HeapAlloc")
	procHeapCompact                    = modkernel32.NewProc("HeapCompact")
	procHeapCreate                     = modkernel32.NewProc("HeapCreate")
	procHeapDestroy                    = modkernel32.NewProc("HeapDestroy")
	procHeapFree                       = modkernel32.NewProc("HeapFree")
	procHeapReAlloc                    = modkernel32.NewProc("HeapReAlloc")
	procHeapSize                       = modkernel32.NewProc("HeapSize")
	procHeapValidate                   = modkernel32.NewProc("HeapValidate")
	procInitializeCriticalSection      = modkernel32.NewProc("InitializeCriticalSection")
	procLeaveCriticalSection           = modkernel32.NewProc("LeaveCriticalSection")
	procLoadLibraryA                   = modkernel32.NewProc("LoadLibraryA")
	procLoadLibraryW                   = modkernel32.NewProc("LoadLibraryW")
	procLocalFree                      = modkernel32.NewProc("LocalFree")
	procLockFile                       = modkernel32.NewProc("LockFile")
	procLockFileEx                     = modkernel32.NewProc("LockFileEx")
	procMapViewOfFile                  = modkernel32.NewProc("MapViewOfFile")
	procMultiByteToWideChar            = modkernel32.NewProc("MultiByteToWideChar")
	procOutputDebugStringA             = modkernel32.NewProc("OutputDebugStringA")
	procOutputDebugStringW             = modkernel32.NewProc("OutputDebugStringW")
	procQueryPerformanceCounter        = modkernel32.NewProc("QueryPerformanceCounter")
	procReadFile                       = modkernel32.NewProc("ReadFile")
	procSetEndOfFile                   = modkernel32.NewProc("SetEndOfFile")
	procSetFilePointer                 = modkernel32.NewProc("SetFilePointer")
	procSleep                          = modkernel32.NewProc("Sleep")
	procSystemTimeToFileTime           = modkernel32.NewProc("SystemTimeToFileTime")
	procUnlockFile                     = modkernel32.NewProc("UnlockFile")
	procUnlockFileEx                   = modkernel32.NewProc("UnlockFileEx")
	procUnmapViewOfFile                = modkernel32.NewProc("UnmapViewOfFile")
	procWaitForSingleObject            = modkernel32.NewProc("WaitForSingleObject")
	procWaitForSingleObjectEx          = modkernel32.NewProc("WaitForSingleObjectEx")
	procWideCharToMultiByte            = modkernel32.NewProc("WideCharToMultiByte")
	procWriteFile                      = modkernel32.NewProc("WriteFile")
)

func init() {
	registerBuiltins(map[int]Opcode{
		dict.SID("AreFileApisANSI"): AreFileApisANSI,
		dict.SID("CreateFileA"): CreateFileA,
		dict.SID("CreateFileW"): CreateFileW,
		dict.SID("CreateFileMappingA"): CreateFileMappingA,
		dict.SID("CreateFileMappingW"): CreateFileMappingW,
		dict.SID("CreateMutexW"): CreateMutexW,
		dict.SID("CloseHandle"): CloseHandle,
		dict.SID("DeleteCriticalSection"): DeleteCriticalSection,
		dict.SID("DeleteFileA"): DeleteFileA,
		dict.SID("DeleteFileW"): DeleteFileW,
		dict.SID("EnterCriticalSection"): EnterCriticalSection,
		dict.SID("FlushFileBuffers"): FlushFileBuffers,
		dict.SID("FlushViewOfFile"): FlushViewOfFile,
		dict.SID("FormatMessageA"): FormatMessageA,
		dict.SID("FormatMessageW"): FormatMessageW,
		dict.SID("FreeLibrary"): FreeLibrary,
		dict.SID("GetCurrentProcessId"): GetCurrentProcessId,
		dict.SID("GetDiskFreeSpaceA"): GetDiskFreeSpaceA,
		dict.SID("GetDiskFreeSpaceW"): GetDiskFreeSpaceW,
		dict.SID("GetFileAttributesExW"): GetFileAttributesExW,
		dict.SID("GetFileAttributesA"): GetFileAttributesA,
		dict.SID("GetFileAttributesW"): GetFileAttributesW,
		dict.SID("GetFileSize"): GetFileSize,
		dict.SID("GetFullPathNameA"): GetFullPathNameA,
		dict.SID("GetFullPathNameW"): GetFullPathNameW,
		dict.SID("GetProcAddress"): GetProcAddress,
		dict.SID("GetProcessHeap"): GetProcessHeap,
		dict.SID("GetSystemInfo"): GetSystemInfo,
		dict.SID("GetSystemTime"): GetSystemTime,
		dict.SID("GetSystemTimeAsFileTime"): GetSystemTimeAsFileTime,
		dict.SID("GetTempPathA"): GetTempPathA,
		dict.SID("GetTempPathW"): GetTempPathW,
		dict.SID("GetTickCount"): GetTickCount,
		dict.SID("GetVersionExA"): GetVersionExA,
		dict.SID("GetVersionExW"): GetVersionExW,
		dict.SID("HeapAlloc"): HeapAlloc,
		dict.SID("HeapCompact"): HeapCompact,
		dict.SID("HeapCreate"): HeapCreate,
		dict.SID("HeapDestroy"): HeapDestroy,
		dict.SID("HeapFree"): HeapFree,
		dict.SID("HeapReAlloc"): HeapReAlloc,
		dict.SID("HeapSize"): HeapSize,
		dict.SID("HeapValidate"): HeapValidate,
		dict.SID("InitializeCriticalSection"): InitializeCriticalSection,
		dict.SID("LeaveCriticalSection"): LeaveCriticalSection,
		dict.SID("LoadLibraryA"): LoadLibraryA,
		dict.SID("LoadLibraryW"): LoadLibraryW,
		dict.SID("LocalFree"): LocalFree,
		dict.SID("LockFile"): LockFile,
		dict.SID("LockFileEx"): LockFileEx,
		dict.SID("MapViewOfFile"): MapViewOfFile,
		dict.SID("MultiByteToWideChar"): MultiByteToWideChar,
		dict.SID("OutputDebugStringA"): OutputDebugStringA,
		dict.SID("OutputDebugStringW"): OutputDebugStringW,
		dict.SID("QueryPerformanceCounter"): QueryPerformanceCounter,
		dict.SID("ReadFile"): ReadFile,
		dict.SID("SetEndOfFile"): SetEndOfFile,
		dict.SID("SetFilePointer"): SetFilePointer,
		dict.SID("Sleep"): Sleep,
		dict.SID("SystemTimeToFileTime"): SystemTimeToFileTime,
		dict.SID("UnlockFile"): UnlockFile,
		dict.SID("UnlockFileEx"): UnlockFileEx,
		dict.SID("UnmapViewOfFile"): UnmapViewOfFile,
		dict.SID("WaitForSingleObject"): WaitForSingleObject,
		dict.SID("WaitForSingleObjectEx"): WaitForSingleObjectEx,
		dict.SID("WideCharToMultiByte"): WideCharToMultiByte,
		dict.SID("WriteFile"): WriteFile,
	})
}

// //sys:kernel32: BOOL   	AreFileApisANSI(); 
func (c *cpu) AreFileApisANSI() {

	ret, _, err := syscall.Syscall(procAreFileApisANSI.Addr(), 0, 0, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "AreFileApisANSI() %#x %v\n", ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: HANDLE 	CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); 
func (c *cpu) CreateFileA() {
	sp := c.sp
	sp, hTemplateFile := popPtr(sp)
	sp, dwFlagsAndAttributes := popI32(sp)
	sp, dwCreationDisposition := popI32(sp)
	sp, lpSecurityAttributes := popPtr(sp)
	sp, dwShareMode := popI32(sp)
	sp, dwDesiredAccess := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall9(procCreateFileA.Addr(), 7, lpFileName, 
		uintptr(dwDesiredAccess), 
		uintptr(dwShareMode), 
		lpSecurityAttributes, 
		uintptr(dwCreationDisposition), 
		uintptr(dwFlagsAndAttributes), 
		hTemplateFile, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "CreateFileA(%s, %#x, %#x, %#x, %#x, %#x, %#x) %#x %v\n", GoUTF16String(lpFileName), 
			dwDesiredAccess, 
			dwShareMode, 
			lpSecurityAttributes, 
			dwCreationDisposition, 
			dwFlagsAndAttributes, 
			hTemplateFile, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: HANDLE 	CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); 
func (c *cpu) CreateFileW() {
	sp := c.sp
	sp, hTemplateFile := popPtr(sp)
	sp, dwFlagsAndAttributes := popI32(sp)
	sp, dwCreationDisposition := popI32(sp)
	sp, lpSecurityAttributes := popPtr(sp)
	sp, dwShareMode := popI32(sp)
	sp, dwDesiredAccess := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall9(procCreateFileW.Addr(), 7, lpFileName, 
		uintptr(dwDesiredAccess), 
		uintptr(dwShareMode), 
		lpSecurityAttributes, 
		uintptr(dwCreationDisposition), 
		uintptr(dwFlagsAndAttributes), 
		hTemplateFile, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "CreateFileW(%s, %#x, %#x, %#x, %#x, %#x, %#x) %#x %v\n", GoUTF16String(lpFileName), 
			dwDesiredAccess, 
			dwShareMode, 
			lpSecurityAttributes, 
			dwCreationDisposition, 
			dwFlagsAndAttributes, 
			hTemplateFile, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: HANDLE 	CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName); 
func (c *cpu) CreateFileMappingA() {
	sp := c.sp
	sp, lpName := popPtr(sp)
	sp, dwMaximumSizeLow := popI32(sp)
	sp, dwMaximumSizeHigh := popI32(sp)
	sp, flProtect := popI32(sp)
	sp, lpAttributes := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procCreateFileMappingA.Addr(), 6, hFile, 
		lpAttributes, 
		uintptr(flProtect), 
		uintptr(dwMaximumSizeHigh), 
		uintptr(dwMaximumSizeLow), 
		lpName);
	if strace {
		fmt.Fprintf(os.Stderr, "CreateFileMappingA(%#x, %#x, %#x, %#x, %#x, %s) %#x %v\n", hFile, 
			lpAttributes, 
			flProtect, 
			dwMaximumSizeHigh, 
			dwMaximumSizeLow, 
			GoUTF16String(lpName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: HANDLE 	CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName); 
func (c *cpu) CreateFileMappingW() {
	sp := c.sp
	sp, lpName := popPtr(sp)
	sp, dwMaximumSizeLow := popI32(sp)
	sp, dwMaximumSizeHigh := popI32(sp)
	sp, flProtect := popI32(sp)
	sp, lpAttributes := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procCreateFileMappingW.Addr(), 6, hFile, 
		lpAttributes, 
		uintptr(flProtect), 
		uintptr(dwMaximumSizeHigh), 
		uintptr(dwMaximumSizeLow), 
		lpName);
	if strace {
		fmt.Fprintf(os.Stderr, "CreateFileMappingW(%#x, %#x, %#x, %#x, %#x, %s) %#x %v\n", hFile, 
			lpAttributes, 
			flProtect, 
			dwMaximumSizeHigh, 
			dwMaximumSizeLow, 
			GoUTF16String(lpName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: HANDLE 	CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName); 
func (c *cpu) CreateMutexW() {
	sp := c.sp
	sp, lpName := popPtr(sp)
	sp, bInitialOwner := popI32(sp)
	sp, lpMutexAttributes := popPtr(sp)

	ret, _, err := syscall.Syscall(procCreateMutexW.Addr(), 3, lpMutexAttributes, 
		uintptr(bInitialOwner), 
		lpName);
	if strace {
		fmt.Fprintf(os.Stderr, "CreateMutexW(%#x, %#x, %s) %#x %v\n", lpMutexAttributes, 
			bInitialOwner, 
			GoUTF16String(lpName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: BOOL   	CloseHandle(HANDLE hObject); 
func (c *cpu) CloseHandle() {
	sp := c.sp
	sp, hObject := popPtr(sp)

	ret, _, err := syscall.Syscall(procCloseHandle.Addr(), 1, hObject, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "CloseHandle(%#x) %#x %v\n", hObject, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: void   	DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection); 
func (c *cpu) DeleteCriticalSection() {
	sp := c.sp
	sp, lpCriticalSection := popPtr(sp)

	ret, _, err := syscall.Syscall(procDeleteCriticalSection.Addr(), 1, lpCriticalSection, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "DeleteCriticalSection(%#x) %d %v\n", lpCriticalSection, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: BOOL   	DeleteFileA(LPCTSTR lpFileName); 
func (c *cpu) DeleteFileA() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procDeleteFileA.Addr(), 1, lpFileName, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "DeleteFileA(%s) %#x %v\n", GoUTF16String(lpFileName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	DeleteFileW(LPCTSTR lpFileName); 
func (c *cpu) DeleteFileW() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procDeleteFileW.Addr(), 1, lpFileName, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "DeleteFileW(%s) %#x %v\n", GoUTF16String(lpFileName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: void   	EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection); 
func (c *cpu) EnterCriticalSection() {
	sp := c.sp
	sp, lpCriticalSection := popPtr(sp)

	ret, _, err := syscall.Syscall(procEnterCriticalSection.Addr(), 1, lpCriticalSection, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "EnterCriticalSection(%#x) %d %v\n", lpCriticalSection, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: BOOL   	FlushFileBuffers(HANDLE hFile); 
func (c *cpu) FlushFileBuffers() {
	sp := c.sp
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall(procFlushFileBuffers.Addr(), 1, hFile, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "FlushFileBuffers(%#x) %#x %v\n", hFile, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL     FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush); 
func (c *cpu) FlushViewOfFile() {
	sp := c.sp
	sp, dwNumberOfBytesToFlush := popPtr(sp)
	sp, lpBaseAddress := popPtr(sp)

	ret, _, err := syscall.Syscall(procFlushViewOfFile.Addr(), 2, lpBaseAddress, 
		dwNumberOfBytesToFlush, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "FlushViewOfFile(%#x, %#x) %#x %v\n", lpBaseAddress, 
			dwNumberOfBytesToFlush, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list* Arguments); 
func (c *cpu) FormatMessageA() {
	sp := c.sp
	sp, Arguments := popPtr(sp)
	sp, nSize := popI32(sp)
	sp, lpBuffer := popPtr(sp)
	sp, dwLanguageId := popI32(sp)
	sp, dwMessageId := popI32(sp)
	sp, lpSource := popPtr(sp)
	sp, dwFlags := popI32(sp)

	ret, _, err := syscall.Syscall9(procFormatMessageA.Addr(), 7, uintptr(dwFlags), 
		lpSource, 
		uintptr(dwMessageId), 
		uintptr(dwLanguageId), 
		lpBuffer, 
		uintptr(nSize), 
		Arguments, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "FormatMessageA(%#x, %#x, %#x, %#x, %s, %#x, %#x) %#x %v\n", dwFlags, 
			lpSource, 
			dwMessageId, 
			dwLanguageId, 
			GoUTF16String(lpBuffer), 
			nSize, 
			Arguments, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list* Arguments); 
func (c *cpu) FormatMessageW() {
	sp := c.sp
	sp, Arguments := popPtr(sp)
	sp, nSize := popI32(sp)
	sp, lpBuffer := popPtr(sp)
	sp, dwLanguageId := popI32(sp)
	sp, dwMessageId := popI32(sp)
	sp, lpSource := popPtr(sp)
	sp, dwFlags := popI32(sp)

	ret, _, err := syscall.Syscall9(procFormatMessageW.Addr(), 7, uintptr(dwFlags), 
		lpSource, 
		uintptr(dwMessageId), 
		uintptr(dwLanguageId), 
		lpBuffer, 
		uintptr(nSize), 
		Arguments, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "FormatMessageW(%#x, %#x, %#x, %#x, %s, %#x, %#x) %#x %v\n", dwFlags, 
			lpSource, 
			dwMessageId, 
			dwLanguageId, 
			GoUTF16String(lpBuffer), 
			nSize, 
			Arguments, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	FreeLibrary(HMODULE hModule); 
func (c *cpu) FreeLibrary() {
	sp := c.sp
	sp, hModule := popPtr(sp)

	ret, _, err := syscall.Syscall(procFreeLibrary.Addr(), 1, hModule, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "FreeLibrary(%#x) %#x %v\n", hModule, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	GetCurrentProcessId(); 
func (c *cpu) GetCurrentProcessId() {

	ret, _, err := syscall.Syscall(procGetCurrentProcessId.Addr(), 0, 0, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetCurrentProcessId() %#x %v\n", ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	GetDiskFreeSpaceA(LPCTSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters); 
func (c *cpu) GetDiskFreeSpaceA() {
	sp := c.sp
	sp, lpTotalNumberOfClusters := popPtr(sp)
	sp, lpNumberOfFreeClusters := popPtr(sp)
	sp, lpBytesPerSector := popPtr(sp)
	sp, lpSectorsPerCluster := popPtr(sp)
	sp, lpRootPathName := popPtr(sp)

	ret, _, err := syscall.Syscall6(procGetDiskFreeSpaceA.Addr(), 5, lpRootPathName, 
		lpSectorsPerCluster, 
		lpBytesPerSector, 
		lpNumberOfFreeClusters, 
		lpTotalNumberOfClusters, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetDiskFreeSpaceA(%s, %#x, %#x, %#x, %#x) %#x %v\n", GoUTF16String(lpRootPathName), 
			lpSectorsPerCluster, 
			lpBytesPerSector, 
			lpNumberOfFreeClusters, 
			lpTotalNumberOfClusters, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	GetDiskFreeSpaceW(LPCTSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters); 
func (c *cpu) GetDiskFreeSpaceW() {
	sp := c.sp
	sp, lpTotalNumberOfClusters := popPtr(sp)
	sp, lpNumberOfFreeClusters := popPtr(sp)
	sp, lpBytesPerSector := popPtr(sp)
	sp, lpSectorsPerCluster := popPtr(sp)
	sp, lpRootPathName := popPtr(sp)

	ret, _, err := syscall.Syscall6(procGetDiskFreeSpaceW.Addr(), 5, lpRootPathName, 
		lpSectorsPerCluster, 
		lpBytesPerSector, 
		lpNumberOfFreeClusters, 
		lpTotalNumberOfClusters, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetDiskFreeSpaceW(%s, %#x, %#x, %#x, %#x) %#x %v\n", GoUTF16String(lpRootPathName), 
			lpSectorsPerCluster, 
			lpBytesPerSector, 
			lpNumberOfFreeClusters, 
			lpTotalNumberOfClusters, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	GetFileAttributesExW(LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation); 
func (c *cpu) GetFileAttributesExW() {
	sp := c.sp
	sp, lpFileInformation := popPtr(sp)
	sp, fInfoLevelId := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetFileAttributesExW.Addr(), 3, lpFileName, 
		uintptr(fInfoLevelId), 
		lpFileInformation);
	if strace {
		fmt.Fprintf(os.Stderr, "GetFileAttributesExW(%s, %#x, %#x) %#x %v\n", GoUTF16String(lpFileName), 
			fInfoLevelId, 
			lpFileInformation, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	GetFileAttributesA(LPCTSTR lpFileName); 
func (c *cpu) GetFileAttributesA() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetFileAttributesA.Addr(), 1, lpFileName, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetFileAttributesA(%s) %#x %v\n", GoUTF16String(lpFileName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	GetFileAttributesW(LPCTSTR lpFileName); 
func (c *cpu) GetFileAttributesW() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetFileAttributesW.Addr(), 1, lpFileName, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetFileAttributesW(%s) %#x %v\n", GoUTF16String(lpFileName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh); 
func (c *cpu) GetFileSize() {
	sp := c.sp
	sp, lpFileSizeHigh := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetFileSize.Addr(), 2, hFile, 
		lpFileSizeHigh, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetFileSize(%#x, %#x) %#x %v\n", hFile, 
			lpFileSizeHigh, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	GetFullPathNameA( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart); 
func (c *cpu) GetFullPathNameA() {
	sp := c.sp
	sp, lpFilePart := popPtr(sp)
	sp, lpBuffer := popPtr(sp)
	sp, nBufferLength := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall6(procGetFullPathNameA.Addr(), 4, lpFileName, 
		uintptr(nBufferLength), 
		lpBuffer, 
		lpFilePart, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetFullPathNameA(%s, %#x, %s, %#x) %#x %v\n", GoUTF16String(lpFileName), 
			nBufferLength, 
			GoUTF16String(lpBuffer), 
			lpFilePart, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	GetFullPathNameW( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart); 
func (c *cpu) GetFullPathNameW() {
	sp := c.sp
	sp, lpFilePart := popPtr(sp)
	sp, lpBuffer := popPtr(sp)
	sp, nBufferLength := popI32(sp)
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall6(procGetFullPathNameW.Addr(), 4, lpFileName, 
		uintptr(nBufferLength), 
		lpBuffer, 
		lpFilePart, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetFullPathNameW(%s, %#x, %s, %#x) %#x %v\n", GoUTF16String(lpFileName), 
			nBufferLength, 
			GoUTF16String(lpBuffer), 
			lpFilePart, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: FARPROC 	GetProcAddress(HMODULE hModule, LPCSTR lpProcName); 
func (c *cpu) GetProcAddress() {
	sp := c.sp
	sp, lpProcName := popPtr(sp)
	sp, hModule := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetProcAddress.Addr(), 2, hModule, 
		lpProcName, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetProcAddress(%#x, %s) %#x %v\n", hModule, 
			GoUTF16String(lpProcName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: HANDLE   GetProcessHeap(); 
func (c *cpu) GetProcessHeap() {

	ret, _, err := syscall.Syscall(procGetProcessHeap.Addr(), 0, 0, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetProcessHeap() %#x %v\n", ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: void   	GetSystemInfo(LPSYSTEM_INFO lpSystemInfo); 
func (c *cpu) GetSystemInfo() {
	sp := c.sp
	sp, lpSystemInfo := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetSystemInfo.Addr(), 1, lpSystemInfo, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetSystemInfo(%#x) %d %v\n", lpSystemInfo, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: void   	GetSystemTime(LPSYSTEMTIME lpSystemTime); 
func (c *cpu) GetSystemTime() {
	sp := c.sp
	sp, lpSystemTime := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetSystemTime.Addr(), 1, lpSystemTime, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetSystemTime(%#x) %d %v\n", lpSystemTime, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: void     GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime); 
func (c *cpu) GetSystemTimeAsFileTime() {
	sp := c.sp
	sp, lpSystemTimeAsFileTime := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetSystemTimeAsFileTime.Addr(), 1, lpSystemTimeAsFileTime, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetSystemTimeAsFileTime(%#x) %d %v\n", lpSystemTimeAsFileTime, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: DWORD    GetTempPathA(DWORD nBufferLength, LPTSTR lpBuffer); 
func (c *cpu) GetTempPathA() {
	sp := c.sp
	sp, lpBuffer := popPtr(sp)
	sp, nBufferLength := popI32(sp)

	ret, _, err := syscall.Syscall(procGetTempPathA.Addr(), 2, uintptr(nBufferLength), 
		lpBuffer, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetTempPathA(%#x, %s) %#x %v\n", nBufferLength, 
			GoUTF16String(lpBuffer), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD    GetTempPathW(DWORD nBufferLength, LPTSTR lpBuffer); 
func (c *cpu) GetTempPathW() {
	sp := c.sp
	sp, lpBuffer := popPtr(sp)
	sp, nBufferLength := popI32(sp)

	ret, _, err := syscall.Syscall(procGetTempPathW.Addr(), 2, uintptr(nBufferLength), 
		lpBuffer, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetTempPathW(%#x, %s) %#x %v\n", nBufferLength, 
			GoUTF16String(lpBuffer), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD  	GetTickCount(); 
func (c *cpu) GetTickCount() {

	ret, _, err := syscall.Syscall(procGetTickCount.Addr(), 0, 0, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetTickCount() %#x %v\n", ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	GetVersionExA(LPOSVERSIONINFO lpVersionInfo); 
func (c *cpu) GetVersionExA() {
	sp := c.sp
	sp, lpVersionInfo := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetVersionExA.Addr(), 1, lpVersionInfo, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetVersionExA(%#x) %#x %v\n", lpVersionInfo, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	GetVersionExW(LPOSVERSIONINFO lpVersionInfo); 
func (c *cpu) GetVersionExW() {
	sp := c.sp
	sp, lpVersionInfo := popPtr(sp)

	ret, _, err := syscall.Syscall(procGetVersionExW.Addr(), 1, lpVersionInfo, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "GetVersionExW(%#x) %#x %v\n", lpVersionInfo, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: LPVOID 	HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes); 
func (c *cpu) HeapAlloc() {
	sp := c.sp
	sp, dwBytes := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapAlloc.Addr(), 3, hHeap, 
		uintptr(dwFlags), 
		dwBytes);
	if strace {
		fmt.Fprintf(os.Stderr, "HeapAlloc(%#x, %#x, %#x) %#x %v\n", hHeap, 
			dwFlags, 
			dwBytes, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: SIZE_T   HeapCompact(HANDLE hHeap, DWORD dwFlags); 
func (c *cpu) HeapCompact() {
	sp := c.sp
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapCompact.Addr(), 2, hHeap, 
		uintptr(dwFlags), 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "HeapCompact(%#x, %#x) %#x %v\n", hHeap, 
			dwFlags, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: HANDLE   HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize); 
func (c *cpu) HeapCreate() {
	sp := c.sp
	sp, dwMaximumSize := popPtr(sp)
	sp, dwInitialSize := popPtr(sp)
	sp, flOptions := popI32(sp)

	ret, _, err := syscall.Syscall(procHeapCreate.Addr(), 3, uintptr(flOptions), 
		dwInitialSize, 
		dwMaximumSize);
	if strace {
		fmt.Fprintf(os.Stderr, "HeapCreate(%#x, %#x, %#x) %#x %v\n", flOptions, 
			dwInitialSize, 
			dwMaximumSize, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: BOOL     HeapDestroy(HANDLE hHeap); 
func (c *cpu) HeapDestroy() {
	sp := c.sp
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapDestroy.Addr(), 1, hHeap, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "HeapDestroy(%#x) %#x %v\n", hHeap, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL     HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem); 
func (c *cpu) HeapFree() {
	sp := c.sp
	sp, lpMem := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapFree.Addr(), 3, hHeap, 
		uintptr(dwFlags), 
		lpMem);
	if strace {
		fmt.Fprintf(os.Stderr, "HeapFree(%#x, %#x, %#x) %#x %v\n", hHeap, 
			dwFlags, 
			lpMem, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: LPVOID   HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes); 
func (c *cpu) HeapReAlloc() {
	sp := c.sp
	sp, dwBytes := popPtr(sp)
	sp, lpMem := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall6(procHeapReAlloc.Addr(), 4, hHeap, 
		uintptr(dwFlags), 
		lpMem, 
		dwBytes, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "HeapReAlloc(%#x, %#x, %#x, %#x) %#x %v\n", hHeap, 
			dwFlags, 
			lpMem, 
			dwBytes, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: SIZE_T   HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem); 
func (c *cpu) HeapSize() {
	sp := c.sp
	sp, lpMem := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapSize.Addr(), 3, hHeap, 
		uintptr(dwFlags), 
		lpMem);
	if strace {
		fmt.Fprintf(os.Stderr, "HeapSize(%#x, %#x, %#x) %#x %v\n", hHeap, 
			dwFlags, 
			lpMem, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: BOOL     HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem); 
func (c *cpu) HeapValidate() {
	sp := c.sp
	sp, lpMem := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, hHeap := popPtr(sp)

	ret, _, err := syscall.Syscall(procHeapValidate.Addr(), 3, hHeap, 
		uintptr(dwFlags), 
		lpMem);
	if strace {
		fmt.Fprintf(os.Stderr, "HeapValidate(%#x, %#x, %#x) %#x %v\n", hHeap, 
			dwFlags, 
			lpMem, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: void   	InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection); 
func (c *cpu) InitializeCriticalSection() {
	sp := c.sp
	sp, lpCriticalSection := popPtr(sp)

	ret, _, err := syscall.Syscall(procInitializeCriticalSection.Addr(), 1, lpCriticalSection, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "InitializeCriticalSection(%#x) %d %v\n", lpCriticalSection, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: void   	LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection); 
func (c *cpu) LeaveCriticalSection() {
	sp := c.sp
	sp, lpCriticalSection := popPtr(sp)

	ret, _, err := syscall.Syscall(procLeaveCriticalSection.Addr(), 1, lpCriticalSection, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "LeaveCriticalSection(%#x) %d %v\n", lpCriticalSection, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: HMODULE  LoadLibraryA(LPCTSTR lpFileName); 
func (c *cpu) LoadLibraryA() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procLoadLibraryA.Addr(), 1, lpFileName, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "LoadLibraryA(%s) %#x %v\n", GoUTF16String(lpFileName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: HMODULE  LoadLibraryW(LPCTSTR lpFileName); 
func (c *cpu) LoadLibraryW() {
	sp := c.sp
	sp, lpFileName := popPtr(sp)

	ret, _, err := syscall.Syscall(procLoadLibraryW.Addr(), 1, lpFileName, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "LoadLibraryW(%s) %#x %v\n", GoUTF16String(lpFileName), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: HLOCAL 	LocalFree(HLOCAL hMem); 
func (c *cpu) LocalFree() {
	sp := c.sp
	sp, hMem := popPtr(sp)

	ret, _, err := syscall.Syscall(procLocalFree.Addr(), 1, hMem, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "LocalFree(%#x) %#x %v\n", hMem, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: BOOL     LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh); 
func (c *cpu) LockFile() {
	sp := c.sp
	sp, nNumberOfBytesToLockHigh := popI32(sp)
	sp, nNumberOfBytesToLockLow := popI32(sp)
	sp, dwFileOffsetHigh := popI32(sp)
	sp, dwFileOffsetLow := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procLockFile.Addr(), 5, hFile, 
		uintptr(dwFileOffsetLow), 
		uintptr(dwFileOffsetHigh), 
		uintptr(nNumberOfBytesToLockLow), 
		uintptr(nNumberOfBytesToLockHigh), 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "LockFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile, 
			dwFileOffsetLow, 
			dwFileOffsetHigh, 
			nNumberOfBytesToLockLow, 
			nNumberOfBytesToLockHigh, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped); 
func (c *cpu) LockFileEx() {
	sp := c.sp
	sp, lpOverlapped := popPtr(sp)
	sp, nNumberOfBytesToLockHigh := popI32(sp)
	sp, nNumberOfBytesToLockLow := popI32(sp)
	sp, dwReserved := popI32(sp)
	sp, dwFlags := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procLockFileEx.Addr(), 6, hFile, 
		uintptr(dwFlags), 
		uintptr(dwReserved), 
		uintptr(nNumberOfBytesToLockLow), 
		uintptr(nNumberOfBytesToLockHigh), 
		lpOverlapped);
	if strace {
		fmt.Fprintf(os.Stderr, "LockFileEx(%#x, %#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile, 
			dwFlags, 
			dwReserved, 
			nNumberOfBytesToLockLow, 
			nNumberOfBytesToLockHigh, 
			lpOverlapped, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: LPVOID   MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap); 
func (c *cpu) MapViewOfFile() {
	sp := c.sp
	sp, dwNumberOfBytesToMap := popPtr(sp)
	sp, dwFileOffsetLow := popI32(sp)
	sp, dwFileOffsetHigh := popI32(sp)
	sp, dwDesiredAccess := popI32(sp)
	sp, hFileMappingObject := popPtr(sp)

	ret, _, err := syscall.Syscall6(procMapViewOfFile.Addr(), 5, hFileMappingObject, 
		uintptr(dwDesiredAccess), 
		uintptr(dwFileOffsetHigh), 
		uintptr(dwFileOffsetLow), 
		dwNumberOfBytesToMap, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "MapViewOfFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFileMappingObject, 
			dwDesiredAccess, 
			dwFileOffsetHigh, 
			dwFileOffsetLow, 
			dwNumberOfBytesToMap, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writePtr(c.rp, ret)
}

// //sys:kernel32: int 	  	MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr,	int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar); 
func (c *cpu) MultiByteToWideChar() {
	sp := c.sp
	sp, cchWideChar := popI32(sp)
	sp, lpWideCharStr := popPtr(sp)
	sp, cbMultiByte := popI32(sp)
	sp, lpMultiByteStr := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, CodePage := popI32(sp)

	ret, _, err := syscall.Syscall6(procMultiByteToWideChar.Addr(), 6, uintptr(CodePage), 
		uintptr(dwFlags), 
		lpMultiByteStr, 
		uintptr(cbMultiByte), 
		lpWideCharStr, 
		uintptr(cchWideChar));
	if strace {
		fmt.Fprintf(os.Stderr, "MultiByteToWideChar(%#x, %#x, %s, %#x, %s, %#x) %#x %v\n", CodePage, 
			dwFlags, 
			GoUTF16String(lpMultiByteStr), 
			cbMultiByte, 
			GoUTF16String(lpWideCharStr), 
			cchWideChar, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: void     OutputDebugStringA(LPCTSTR lpOutputString); 
func (c *cpu) OutputDebugStringA() {
	sp := c.sp
	sp, lpOutputString := popPtr(sp)

	ret, _, err := syscall.Syscall(procOutputDebugStringA.Addr(), 1, lpOutputString, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "OutputDebugStringA(%s) %d %v\n", GoUTF16String(lpOutputString), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: void     OutputDebugStringW(LPCTSTR lpOutputString); 
func (c *cpu) OutputDebugStringW() {
	sp := c.sp
	sp, lpOutputString := popPtr(sp)

	ret, _, err := syscall.Syscall(procOutputDebugStringW.Addr(), 1, lpOutputString, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "OutputDebugStringW(%s) %d %v\n", GoUTF16String(lpOutputString), 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: BOOL   	QueryPerformanceCounter(LARGE_INTEGER* lpPerformanceCount); 
func (c *cpu) QueryPerformanceCounter() {
	sp := c.sp
	sp, lpPerformanceCount := popPtr(sp)

	ret, _, err := syscall.Syscall(procQueryPerformanceCounter.Addr(), 1, lpPerformanceCount, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "QueryPerformanceCounter(%#x) %#x %v\n", lpPerformanceCount, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped); 
func (c *cpu) ReadFile() {
	sp := c.sp
	sp, lpOverlapped := popPtr(sp)
	sp, lpNumberOfBytesRead := popPtr(sp)
	sp, nNumberOfBytesToRead := popI32(sp)
	sp, lpBuffer := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procReadFile.Addr(), 5, hFile, 
		lpBuffer, 
		uintptr(nNumberOfBytesToRead), 
		lpNumberOfBytesRead, 
		lpOverlapped, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "ReadFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile, 
			lpBuffer, 
			nNumberOfBytesToRead, 
			lpNumberOfBytesRead, 
			lpOverlapped, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL     SetEndOfFile(HANDLE hFile); 
func (c *cpu) SetEndOfFile() {
	sp := c.sp
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall(procSetEndOfFile.Addr(), 1, hFile, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "SetEndOfFile(%#x) %#x %v\n", hFile, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD    SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod); 
func (c *cpu) SetFilePointer() {
	sp := c.sp
	sp, dwMoveMethod := popI32(sp)
	sp, lpDistanceToMoveHigh := popPtr(sp)
	sp, lDistanceToMove := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procSetFilePointer.Addr(), 4, hFile, 
		uintptr(lDistanceToMove), 
		lpDistanceToMoveHigh, 
		uintptr(dwMoveMethod), 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "SetFilePointer(%#x, %#x, %#x, %#x) %#x %v\n", hFile, 
			lDistanceToMove, 
			lpDistanceToMoveHigh, 
			dwMoveMethod, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: void     Sleep(DWORD dwMilliseconds); 
func (c *cpu) Sleep() {
	sp := c.sp
	sp, dwMilliseconds := popI32(sp)

	ret, _, err := syscall.Syscall(procSleep.Addr(), 1, uintptr(dwMilliseconds), 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "Sleep(%#x) %d %v\n", dwMilliseconds, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	
}

// //sys:kernel32: BOOL     SystemTimeToFileTime(SYSTEMTIME* lpSystemTime, LPFILETIME lpFileTime); 
func (c *cpu) SystemTimeToFileTime() {
	sp := c.sp
	sp, lpFileTime := popPtr(sp)
	sp, lpSystemTime := popPtr(sp)

	ret, _, err := syscall.Syscall(procSystemTimeToFileTime.Addr(), 2, lpSystemTime, 
		lpFileTime, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "SystemTimeToFileTime(%#x, %#x) %#x %v\n", lpSystemTime, 
			lpFileTime, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL     UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh); 
func (c *cpu) UnlockFile() {
	sp := c.sp
	sp, nNumberOfBytesToUnlockHigh := popI32(sp)
	sp, nNumberOfBytesToUnlockLow := popI32(sp)
	sp, dwFileOffsetHigh := popI32(sp)
	sp, dwFileOffsetLow := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procUnlockFile.Addr(), 5, hFile, 
		uintptr(dwFileOffsetLow), 
		uintptr(dwFileOffsetHigh), 
		uintptr(nNumberOfBytesToUnlockLow), 
		uintptr(nNumberOfBytesToUnlockHigh), 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "UnlockFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile, 
			dwFileOffsetLow, 
			dwFileOffsetHigh, 
			nNumberOfBytesToUnlockLow, 
			nNumberOfBytesToUnlockHigh, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped); 
func (c *cpu) UnlockFileEx() {
	sp := c.sp
	sp, lpOverlapped := popPtr(sp)
	sp, nNumberOfBytesToUnlockHigh := popI32(sp)
	sp, nNumberOfBytesToUnlockLow := popI32(sp)
	sp, dwReserved := popI32(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procUnlockFileEx.Addr(), 5, hFile, 
		uintptr(dwReserved), 
		uintptr(nNumberOfBytesToUnlockLow), 
		uintptr(nNumberOfBytesToUnlockHigh), 
		lpOverlapped, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "UnlockFileEx(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile, 
			dwReserved, 
			nNumberOfBytesToUnlockLow, 
			nNumberOfBytesToUnlockHigh, 
			lpOverlapped, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL     UnmapViewOfFile(LPCVOID lpBaseAddress); 
func (c *cpu) UnmapViewOfFile() {
	sp := c.sp
	sp, lpBaseAddress := popPtr(sp)

	ret, _, err := syscall.Syscall(procUnmapViewOfFile.Addr(), 1, lpBaseAddress, 
		0, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "UnmapViewOfFile(%#x) %#x %v\n", lpBaseAddress, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD    WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds); 
func (c *cpu) WaitForSingleObject() {
	sp := c.sp
	sp, dwMilliseconds := popI32(sp)
	sp, hHandle := popPtr(sp)

	ret, _, err := syscall.Syscall(procWaitForSingleObject.Addr(), 2, hHandle, 
		uintptr(dwMilliseconds), 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "WaitForSingleObject(%#x, %#x) %#x %v\n", hHandle, 
			dwMilliseconds, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: DWORD    WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable); 
func (c *cpu) WaitForSingleObjectEx() {
	sp := c.sp
	sp, bAlertable := popI32(sp)
	sp, dwMilliseconds := popI32(sp)
	sp, hHandle := popPtr(sp)

	ret, _, err := syscall.Syscall(procWaitForSingleObjectEx.Addr(), 3, hHandle, 
		uintptr(dwMilliseconds), 
		uintptr(bAlertable));
	if strace {
		fmt.Fprintf(os.Stderr, "WaitForSingleObjectEx(%#x, %#x, %#x) %#x %v\n", hHandle, 
			dwMilliseconds, 
			bAlertable, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: int    	WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar); 
func (c *cpu) WideCharToMultiByte() {
	sp := c.sp
	sp, lpUsedDefaultChar := popPtr(sp)
	sp, lpDefaultChar := popPtr(sp)
	sp, cbMultiByte := popI32(sp)
	sp, lpMultiByteStr := popPtr(sp)
	sp, cchWideChar := popI32(sp)
	sp, lpWideCharStr := popPtr(sp)
	sp, dwFlags := popI32(sp)
	sp, CodePage := popI32(sp)

	ret, _, err := syscall.Syscall9(procWideCharToMultiByte.Addr(), 8, uintptr(CodePage), 
		uintptr(dwFlags), 
		lpWideCharStr, 
		uintptr(cchWideChar), 
		lpMultiByteStr, 
		uintptr(cbMultiByte), 
		lpDefaultChar, 
		lpUsedDefaultChar, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "WideCharToMultiByte(%#x, %#x, %s, %#x, %s, %#x, %s, %#x) %#x %v\n", CodePage, 
			dwFlags, 
			GoUTF16String(lpWideCharStr), 
			cchWideChar, 
			GoUTF16String(lpMultiByteStr), 
			cbMultiByte, 
			GoUTF16String(lpDefaultChar), 
			lpUsedDefaultChar, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

// //sys:kernel32: BOOL   	WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped); 
func (c *cpu) WriteFile() {
	sp := c.sp
	sp, lpOverlapped := popPtr(sp)
	sp, lpNumberOfBytesWritten := popPtr(sp)
	sp, nNumberOfBytesToWrite := popI32(sp)
	sp, lpBuffer := popPtr(sp)
	sp, hFile := popPtr(sp)

	ret, _, err := syscall.Syscall6(procWriteFile.Addr(), 5, hFile, 
		lpBuffer, 
		uintptr(nNumberOfBytesToWrite), 
		lpNumberOfBytesWritten, 
		lpOverlapped, 
		0);
	if strace {
		fmt.Fprintf(os.Stderr, "WriteFile(%#x, %#x, %#x, %#x, %#x) %#x %v\n", hFile, 
			lpBuffer, 
			nNumberOfBytesToWrite, 
			lpNumberOfBytesWritten, 
			lpOverlapped, 
			ret, err)
	}
	if err != 0 {
		c.setErrno(err)
	}
	writeI32(c.rp, int32(ret))
}

